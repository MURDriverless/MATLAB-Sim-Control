clear all
clc

%Load track data generated by 'parse_track.py'
load("track_data")

%Set initial position and pose of Car
cx0 = 0;
cy0 = 0;
ctheta0 = 0;

%Create World for simulation
T = 0.001;
world = World(left_x,left_y,right_x,right_y,tk_x,tk_y,cx0,cy0,ctheta0,T);

%Plot Track to confirm mapping
figure(1)

RESOLUTION = 1000;
           
%Discrete track plot
plot(left_x,left_y,'bo')
hold on
plot(right_x,right_y,'yo')
plot(tk_x,tk_y,'r-s')

%Generate parameterised time vectors corresponding to index
t_l = 1:numel(left_x);
t_r = 1:numel(right_x);
           
%Create x,y positions as vectors
xy_left = [left_x;left_y];
xy_right = [right_x;right_y];
           
%Use spline() to determine coefficients for piecewise Spline 
Left_Spline = spline(t_l,xy_left);
Right_Spline = spline(t_r,xy_right);
           
%Determine finer resolution points with Spline
left_track = ppval(Left_Spline,linspace(1,numel(left_x),RESOLUTION));
right_track = ppval(Right_Spline,linspace(1,numel(right_x),RESOLUTION));
           
plot(left_track(1,:),left_track(2,:),'b')
plot(right_track(1,:),right_track(2,:),'y')
           
plot(cx0,cy0,'gx')
           
xlabel("X(m)")
ylabel("Y(m)")
title("FSG - Driverless Track")

%Create SLAM
cone_n_val = 0;                  %Set 'range' or 'stddev' for cone noise
car_n_val = [0,0,0,0,0,0,0,0,0]; %Set 'range' or 'stddev' for car state noise
R = 10;                          %Set radius of SLAM perception
VelBased = false;                %Set VelocityBased StdDev
slam = SLAM(cone_n_val,car_n_val,R,T,VelBased);
slam.update(world.LCs,world.RCs,world.TKCs,world.Car);

%Create Path Planner
setConstantVelocity = false;
VMax = 10;
VConst = 5;
FGain = 3;
pp = PathPlanner(slam.Cones_N,slam.Car_N,setConstantVelocity,VMax,VConst,FGain);

%Create Controller [Kdd = 1]
minLd = 3;
maxLd = 10;
Kdd = 0.3;
controller = Controller(Kdd,T,minLd,maxLd,FGain);
numGoal = 0;
numLeft = 0;
numRight = 0;
numPoints = 0;

tPP = 0;
tControl = 0;
tSLAM = 0;
tWorld = 0;
tPlot = 0;

counter = 0;
fprintf("STARTING\n")
while true
    if(sqrt(world.Car.XDot(end)^2+world.Car.YDot(end)^2)<0.05 && pp.HaveLeftStartZone)
        break;
    end
    if rem(counter,10)==0
        tic
        slam.update(world.LCs,world.RCs,world.TKCs,world.Car);
        tSLAM = tSLAM + toc;
    end
    if rem(counter,20)==0
        tic
        [X,Y,V] = pp.update(slam.Cones_N,slam.Car_N);
        tPP = tPP + toc;
    end
    if rem(counter,150)==0
        tic
        numPointsPrev = numPoints;
        numGoalPrev = numGoal;
        numLeftPrev = numLeft;
        numRightPrev = numRight;
        numPoints = numel(world.Car.X);
        numGoal = size(pp.CPs,2);
        numLeft = numel(pp.LCs);
        numRight = numel(pp.RCs);
        figure(1)
        plot([pp.LCs(numLeftPrev+1:numLeft).X],[pp.LCs(numLeftPrev+1:numLeft).Y],'kx')
        plot([pp.RCs(numRightPrev+1:numRight).X],[pp.RCs(numRightPrev+1:numRight).Y],'kx')
        plot(pp.CPs(1,numGoalPrev+1:numGoal),pp.CPs(2,numGoalPrev+1:numGoal),'go')
        plot(world.Car.X(numPointsPrev+1:numPoints),world.Car.Y(numPointsPrev+1:numPoints),'b-')
        tPlot = tPlot + toc;
    end
    tic
    [a,DeltaDot] = controller.update(V,X,Y,slam.Car_N);
    tControl = tControl+toc;
    tic
    world.update(a,DeltaDot);
    tWorld = tWorld+toc;
    counter=counter+1;
end

fprintf("Finished Successfully\n")

%BENCHMARK PERFORMANCE
t_theoretical = 0;
for i=1:numel(X)-1
    t_theoretical = t_theoretical + sqrt((X(i)-X(i+1))^2+(Y(i)-Y(i+1))^2)/V(i);
end
fprintf("Calculated Theoretical Time %f\n",t_theoretical);
t_real = world.t(end);
fprintf("Calculated Real Time %f\n",t_real);

e_ref = 0;
for i=1:numel(world.Car.X)
    xr = world.Car.X(i)-world.Car.Lr*cos(world.Car.Theta(i));
    yr = world.Car.Y(i)-world.Car.Lr*sin(world.Car.Theta(i));
    closeDist = realmax;
    for j=1:numel(X)
        xp = X(j);
        yp = Y(j);
        dist = sqrt((xr-xp)^2+(yr-yp)^2);
        if dist<closeDist
            closeDist = dist;
        end
    end
    e_ref = e_ref+closeDist;
end
e_ref_normalised = e_ref/numel(world.t);
fprintf("Calculated Reference Error Normalised: %f - Unnormalised: %f\n",e_ref_normalised,e_ref);

index = 1;
for i=1:size(left_track,2)
    xL = left_track(1,i);
    yL = left_track(2,i);
    closeDist = realmax;
    for j=1:size(right_track,2)
        xR = right_track(1,j);
        yR = right_track(2,j);
        dist = sqrt((xL-xR)^2+(yL-yR)^2);
        if dist<closeDist
            index = j;
            closeDist = dist;
        end
    end
    xMid(i) = (xL+right_track(1,index))/2;
    yMid(i) = (yL+right_track(2,index))/2;
end

e_ref_centre = 0;
for i=1:numel(world.Car.X)
    xr = world.Car.X(i)-world.Car.Lr*cos(world.Car.Theta(i));
    yr = world.Car.Y(i)-world.Car.Lr*sin(world.Car.Theta(i));
    closeDist = realmax;
    for j=1:numel(xMid)
        xp = xMid(j);
        yp = yMid(j);
        dist = sqrt((xr-xp)^2+(yr-yp)^2);
        if dist<closeDist
            closeDist = dist;
        end
    end
    e_ref_centre = e_ref_centre+closeDist;
end
e_ref_c_normalised = e_ref_centre/numel(world.t);
fprintf("Calculated Reference Error (Centre of Track) Normalised: %f - Unnormalised: %f\n",e_ref_c_normalised,e_ref_centre);
        

